# üöÄ Roadmap de Otimiza√ß√µes - IntegrarPlus

**Data**: 28 de Outubro de 2025
**Status**: üìã Planejamento

---

## üìä An√°lise do Estado Atual

### ‚úÖ Pontos Fortes J√° Implementados
- ‚úÖ **Turbo/Hotwire**: Navega√ß√£o SPA-like implementada
- ‚úÖ **Vite**: Build tool moderno configurado
- ‚úÖ **Stimulus**: Controllers organizados
- ‚úÖ **ViewComponents**: Componentiza√ß√£o Ruby
- ‚úÖ **TailwindCSS**: Estiliza√ß√£o otimizada
- ‚úÖ **MeiliSearch**: Busca r√°pida configurada
- ‚úÖ **Solid Queue**: Jobs em background

### üéØ Oportunidades de Melhoria Identificadas

#### Performance
- ‚ö†Ô∏è **N+1 Queries**: Poss√≠veis queries n√£o otimizadas
- ‚ö†Ô∏è **Asset Loading**: Sem estrat√©gia de preload/prefetch
- ‚ö†Ô∏è **Image Optimization**: Imagens sem otimiza√ß√£o
- ‚ö†Ô∏è **Cache Strategy**: Cache n√£o implementado sistematicamente
- ‚ö†Ô∏è **Bundle Size**: Sem code splitting avan√ßado

#### UX/Loading
- ‚ö†Ô∏è **Loading States**: Poucos indicators de carregamento
- ‚ö†Ô∏è **Skeleton Screens**: N√£o implementados
- ‚ö†Ô∏è **Lazy Loading**: Imagens sem lazy load
- ‚ö†Ô∏è **Offline Support**: PWA b√°sico, pode melhorar
- ‚ö†Ô∏è **Error Boundaries**: Tratamento de erros pode melhorar

#### Developer Experience
- ‚ö†Ô∏è **Monitoring**: Sem APM configurado
- ‚ö†Ô∏è **Error Tracking**: Sentry configurado mas pode melhorar
- ‚ö†Ô∏è **Performance Metrics**: Sem Web Vitals tracking
- ‚ö†Ô∏è **CI/CD**: GitHub Actions b√°sico

---

## üéØ Roadmap de Otimiza√ß√µes

### üî¥ Prioridade CR√çTICA (Impacto Alto, Esfor√ßo Baixo)

#### 1. Implementar Loading States Globais
**Problema**: Usu√°rios n√£o sabem quando algo est√° carregando
**Solu√ß√£o**: Loading indicators consistentes

**Implementa√ß√£o**:
```javascript
// app/frontend/javascript/controllers/loading_controller.js
import { Controller } from '@hotwired/stimulus';

export default class extends Controller {
  static targets = ['spinner', 'content'];

  connect() {
    this.showLoading();

    // Turbo events
    document.addEventListener('turbo:before-fetch-request', this.showLoading.bind(this));
    document.addEventListener('turbo:before-fetch-response', this.hideLoading.bind(this));
  }

  showLoading() {
    if (this.hasSpinnerTarget) this.spinnerTarget.classList.remove('hidden');
    if (this.hasContentTarget) this.contentTarget.classList.add('opacity-50');
  }

  hideLoading() {
    if (this.hasSpinnerTarget) this.spinnerTarget.classList.add('hidden');
    if (this.hasContentTarget) this.contentTarget.classList.remove('opacity-50');
  }
}
```

**Impacto**: üìà +30% em perceived performance
**Esfor√ßo**: üïê 2-4 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 2. Otimizar Queries com Bullet Gem
**Problema**: N+1 queries degradando performance

**Implementa√ß√£o**:
```ruby
# Gemfile
gem 'bullet', group: :development

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true
  Bullet.bullet_logger = true
  Bullet.console = true
  Bullet.rails_logger = true
end
```

**A√ß√µes**:
1. Identificar N+1 queries com Bullet
2. Adicionar `includes`/`eager_load` onde necess√°rio
3. Adicionar √≠ndices no banco de dados
4. Usar `select` para buscar apenas campos necess√°rios

**Exemplo de Otimiza√ß√£o**:
```ruby
# ‚ùå ANTES (N+1)
@beneficiaries = Beneficiary.all
# View: @beneficiaries.each { |b| b.anamnesis.nome }

# ‚úÖ DEPOIS
@beneficiaries = Beneficiary.includes(:anamnesis).all
```

**Impacto**: üìà -50% em tempo de resposta
**Esfor√ßo**: üïê 4-8 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 3. Implementar Russian Doll Caching
**Problema**: Views s√£o renderizadas repetidamente

**Implementa√ß√£o**:
```ruby
# app/views/admin/beneficiaries/_beneficiary.html.erb
<% cache beneficiary do %>
  <div class="beneficiary-card">
    <%= beneficiary.nome %>

    <% cache [beneficiary, :anamnesis] do %>
      <%= render beneficiary.anamnesis %>
    <% end %>
  </div>
<% end %>
```

**Configura√ß√£o**:
```ruby
# config/environments/production.rb
config.cache_store = :redis_cache_store, {
  url: ENV['REDIS_URL'],
  expires_in: 90.minutes
}
```

**Impacto**: üìà -60% em tempo de renderiza√ß√£o
**Esfor√ßo**: üïê 6-12 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

### üü† Prioridade ALTA (Impacto Alto, Esfor√ßo M√©dio)

#### 4. Implementar Lazy Loading de Imagens
**Problema**: Todas as imagens carregam imediatamente

**Implementa√ß√£o**:
```ruby
# app/helpers/image_helper.rb
module ImageHelper
  def lazy_image_tag(source, options = {})
    options[:loading] = 'lazy'
    options[:decoding] = 'async'
    options[:class] = "#{options[:class]} lazy-image"

    image_tag(source, options)
  end
end
```

**Controller Stimulus para Progressive Loading**:
```javascript
// app/frontend/javascript/controllers/lazy_image_controller.js
import { Controller } from '@hotwired/stimulus';

export default class extends Controller {
  static values = { src: String, placeholder: String };

  connect() {
    if ('IntersectionObserver' in window) {
      this.observer = new IntersectionObserver(this.loadImage.bind(this));
      this.observer.observe(this.element);
    } else {
      this.loadImage();
    }
  }

  disconnect() {
    if (this.observer) this.observer.disconnect();
  }

  loadImage(entries) {
    if (!entries || entries[0].isIntersecting) {
      const img = new Image();
      img.src = this.srcValue;
      img.onload = () => {
        this.element.src = this.srcValue;
        this.element.classList.add('loaded');
      };
    }
  }
}
```

**Impacto**: üìà -40% em tempo de carregamento inicial
**Esfor√ßo**: üïê 4-6 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 5. Skeleton Screens para Melhor UX
**Problema**: Telas vazias durante carregamento

**Implementa√ß√£o**:
```ruby
# app/components/skeleton_component.rb
class SkeletonComponent < ViewComponent::Base
  def initialize(type: :card, count: 1)
    @type = type
    @count = count
  end
end
```

```erb
<!-- app/components/skeleton_component.html.erb -->
<div class="animate-pulse space-y-4">
  <% @count.times do %>
    <%= render "skeleton_#{@type}" %>
  <% end %>
</div>

<!-- _skeleton_card.html.erb -->
<div class="bg-gray-200 dark:bg-gray-700 rounded-lg p-4">
  <div class="h-4 bg-gray-300 dark:bg-gray-600 rounded w-3/4 mb-2"></div>
  <div class="h-3 bg-gray-300 dark:bg-gray-600 rounded w-1/2"></div>
</div>
```

**Uso com Turbo Frames**:
```erb
<%= turbo_frame_tag "beneficiaries", loading: :lazy do %>
  <%= render SkeletonComponent.new(type: :card, count: 5) %>
<% end %>
```

**Impacto**: üìà +40% em perceived performance
**Esfor√ßo**: üïê 8-12 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 6. Implementar Code Splitting e Preloading
**Problema**: Bundle JavaScript muito grande

**Implementa√ß√£o**:
```javascript
// vite.config.mts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'vendor': ['@hotwired/stimulus', '@hotwired/turbo-rails'],
          'calendar': ['@fullcalendar/core'],
          'charts': ['apexcharts'],
          'forms': ['tom-select'],
        }
      }
    }
  }
});
```

**Preload Critical Resources**:
```erb
<!-- app/views/layouts/application.html.erb -->
<%= vite_javascript_tag 'application',
    'data-turbo-track': 'reload',
    crossorigin: 'anonymous',
    async: true %>

<link rel="preload" href="<%= asset_path('tailadmin-pro.css') %>" as="style">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="dns-prefetch" href="<%= ENV['CDN_URL'] %>">
```

**Impacto**: üìà -30% em bundle size
**Esfor√ßo**: üïê 6-10 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

### üü° Prioridade M√âDIA (Impacto M√©dio, Esfor√ßo M√©dio)

#### 7. Implementar Service Worker Avan√ßado
**Problema**: PWA b√°sico sem cache estrat√©gico

**Implementa√ß√£o**:
```javascript
// public/service-worker.js
const CACHE_VERSION = 'v1';
const CACHE_STATIC = `static-${CACHE_VERSION}`;
const CACHE_DYNAMIC = `dynamic-${CACHE_VERSION}`;
const CACHE_IMAGES = `images-${CACHE_VERSION}`;

// Cache Strategy: Cache First
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Images: Cache First
  if (request.destination === 'image') {
    event.respondWith(cacheFirst(request, CACHE_IMAGES));
  }
  // Static Assets: Cache First
  else if (url.pathname.match(/\.(css|js|woff2)$/)) {
    event.respondWith(cacheFirst(request, CACHE_STATIC));
  }
  // API/HTML: Network First
  else {
    event.respondWith(networkFirst(request, CACHE_DYNAMIC));
  }
});

async function cacheFirst(request, cacheName) {
  const cached = await caches.match(request);
  if (cached) return cached;

  const response = await fetch(request);
  const cache = await caches.open(cacheName);
  cache.put(request, response.clone());
  return response;
}

async function networkFirst(request, cacheName) {
  try {
    const response = await fetch(request);
    const cache = await caches.open(cacheName);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    const cached = await caches.match(request);
    return cached || new Response('Offline');
  }
}
```

**Impacto**: üìà +50% em performance offline
**Esfor√ßo**: üïê 8-12 horas
**ROI**: ‚≠ê‚≠ê‚≠ê

---

#### 8. Implementar Database Connection Pooling
**Problema**: Conex√µes DB n√£o otimizadas

**Implementa√ß√£o**:
```ruby
# config/database.yml
production:
  pool: <%= ENV.fetch("DB_POOL") { 25 } %>
  timeout: 5000
  checkout_timeout: 5
  reaping_frequency: 10

  # PgBouncer configuration
  prepared_statements: false
  advisory_locks: false
```

**PgBouncer Setup**:
```ini
# /etc/pgbouncer/pgbouncer.ini
[databases]
integrarplus = host=localhost port=5432 dbname=integrarplus_production

[pgbouncer]
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 25
reserve_pool_size = 5
reserve_pool_timeout = 3
```

**Impacto**: üìà +100% em concurrent connections
**Esfor√ßo**: üïê 4-6 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 9. Implementar Background Jobs para Opera√ß√µes Pesadas
**Problema**: Opera√ß√µes s√≠ncronas bloqueiam requests

**J√° tem Solid Queue, mas precisa usar mais**:
```ruby
# app/jobs/anamnesis_pdf_generator_job.rb
class AnamnesisPdfGeneratorJob < ApplicationJob
  queue_as :default

  def perform(anamnesis_id)
    anamnesis = Anamnesis.find(anamnesis_id)
    pdf = AnamnesisPdfService.new(anamnesis).generate

    anamnesis.update(pdf_url: upload_to_storage(pdf))

    # Broadcast via Turbo Stream
    Turbo::StreamsChannel.broadcast_update_to(
      "anamnesis_#{anamnesis.id}",
      target: "anamnesis-pdf",
      partial: "anamneses/pdf_ready",
      locals: { anamnesis: anamnesis }
    )
  end
end

# Controller
def generate_pdf
  AnamnesisPdfGeneratorJob.perform_later(@anamnesis.id)

  respond_to do |format|
    format.turbo_stream {
      render turbo_stream: turbo_stream.update(
        "anamnesis-pdf",
        partial: "anamneses/pdf_generating"
      )
    }
  end
end
```

**Opera√ß√µes para Background**:
- Gera√ß√£o de PDFs
- Envio de emails
- Processamento de imagens
- Sincroniza√ß√£o com MeiliSearch
- Limpeza de dados antigos

**Impacto**: üìà -70% em tempo de resposta
**Esfor√ßo**: üïê 12-16 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 10. Implementar HTTP/2 Server Push
**Problema**: M√∫ltiplos round-trips para assets

**Nginx Configuration**:
```nginx
# /etc/nginx/sites-available/integrarplus
server {
    listen 443 ssl http2;
    server_name integrarplus.com;

    # HTTP/2 Server Push
    location = /admin {
        http2_push /assets/application.css;
        http2_push /assets/application.js;
        http2_push /assets/tailadmin-pro.css;

        proxy_pass http://rails_backend;
    }

    # Brotli Compression
    brotli on;
    brotli_comp_level 6;
    brotli_types text/plain text/css application/javascript;

    # Gzip fallback
    gzip on;
    gzip_vary on;
    gzip_types text/plain text/css application/javascript;
}
```

**Impacto**: üìà -20% em tempo de carregamento
**Esfor√ßo**: üïê 4-6 horas
**ROI**: ‚≠ê‚≠ê‚≠ê

---

### üîµ Prioridade BAIXA (Impacto M√©dio, Esfor√ßo Alto)

#### 11. Implementar CDN para Assets Est√°ticos
**Problema**: Assets servidos do servidor principal

**Implementa√ß√£o com Cloudflare**:
```ruby
# config/environments/production.rb
config.asset_host = ENV['CDN_URL']
config.action_controller.asset_host = ENV['CDN_URL']
```

**CloudFlare Workers para Otimiza√ß√£o**:
```javascript
// cloudflare-worker.js
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const cache = caches.default;
  let response = await cache.match(request);

  if (!response) {
    response = await fetch(request);

    // Cache images for 1 year
    if (request.url.match(/\.(jpg|jpeg|png|gif|webp)$/)) {
      response = new Response(response.body, response);
      response.headers.set('Cache-Control', 'public, max-age=31536000');
      event.waitUntil(cache.put(request, response.clone()));
    }
  }

  return response;
}
```

**Impacto**: üìà -40% em lat√™ncia global
**Esfor√ßo**: üïê 8-12 horas
**ROI**: ‚≠ê‚≠ê‚≠ê

---

#### 12. Implementar Monitoring e APM
**Problema**: Sem visibilidade de performance em produ√ß√£o

**Op√ß√µes de APM**:
1. **New Relic** (Completo, pago)
2. **Scout APM** (Rails-focused, acess√≠vel)
3. **Skylight** (Rails-only, visual)

**Implementa√ß√£o Scout APM**:
```ruby
# Gemfile
gem 'scout_apm'

# config/scout_apm.yml
production:
  key: <%= ENV['SCOUT_KEY'] %>
  monitor: true
  name: IntegrarPlus Production

  # Custom Instruments
  instrument:
    - ActiveRecord
    - ActionController
    - ActionView
    - Redis
    - HTTP
```

**Custom Instrumentation**:
```ruby
# app/services/anamnesis_pdf_service.rb
class AnamnesisPdfService
  include ScoutApm::Tracer

  instrument_method :generate, type: 'PDF Generation'

  def generate
    # ... PDF logic
  end
end
```

**Impacto**: üìà Visibilidade completa de performance
**Esfor√ßo**: üïê 6-10 horas
**ROI**: ‚≠ê‚≠ê‚≠ê‚≠ê

---

#### 13. Implementar Web Vitals Tracking
**Problema**: Sem m√©tricas de UX

**Implementa√ß√£o**:
```javascript
// app/frontend/javascript/web-vitals.js
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics({ name, delta, value, id }) {
  fetch('/api/analytics/web-vitals', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ name, delta, value, id })
  });
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

**Dashboard Rails**:
```ruby
# app/controllers/analytics_controller.rb
class AnalyticsController < ApplicationController
  skip_before_action :verify_authenticity_token, only: :web_vitals

  def web_vitals
    WebVitalsMetric.create(
      name: params[:name],
      value: params[:value],
      page: request.referer
    )
    head :ok
  end

  def dashboard
    @metrics = WebVitalsMetric
      .where('created_at > ?', 7.days.ago)
      .group(:name)
      .average(:value)
  end
end
```

**Impacto**: üìà M√©tricas de UX quantific√°veis
**Esfor√ßo**: üïê 10-14 horas
**ROI**: ‚≠ê‚≠ê‚≠ê

---

## üìä Resumo de Prioridades

### Quick Wins (Fazer AGORA)
1. ‚úÖ Loading States Globais (2-4h) ‚Üí +30% perceived perf
2. ‚úÖ Otimizar Queries com Bullet (4-8h) ‚Üí -50% response time
3. ‚úÖ Russian Doll Caching (6-12h) ‚Üí -60% render time

**Total Esfor√ßo**: 12-24 horas
**Impacto Combinado**: üìà +120% em performance percebida

---

### High Impact (Fazer ESTA SEMANA)
4. ‚úÖ Lazy Loading de Imagens (4-6h)
5. ‚úÖ Skeleton Screens (8-12h)
6. ‚úÖ Code Splitting (6-10h)

**Total Esfor√ßo**: 18-28 horas
**Impacto Combinado**: üìà +110% em m√©tricas objetivas

---

### Strategic (Fazer ESTE M√äS)
7. ‚ö†Ô∏è Service Worker Avan√ßado (8-12h)
8. ‚ö†Ô∏è Database Connection Pooling (4-6h)
9. ‚ö†Ô∏è Background Jobs Expansion (12-16h)
10. ‚ö†Ô∏è HTTP/2 Server Push (4-6h)

**Total Esfor√ßo**: 28-40 horas
**Impacto Combinado**: üìà +220% em escalabilidade

---

### Long Term (Fazer PR√ìXIMO TRIMESTRE)
11. üìã CDN Implementation (8-12h)
12. üìã APM/Monitoring (6-10h)
13. üìã Web Vitals Tracking (10-14h)

**Total Esfor√ßo**: 24-36 horas
**Impacto Combinado**: üìà Observability completa

---

## üéØ M√©tricas de Sucesso

### Antes vs Depois (Proje√ß√µes)

| M√©trica | Antes | Meta | Melhoria |
|---------|-------|------|----------|
| **Time to First Byte (TTFB)** | ~800ms | ~200ms | -75% |
| **Largest Contentful Paint (LCP)** | ~2.5s | ~1.2s | -52% |
| **First Input Delay (FID)** | ~100ms | ~50ms | -50% |
| **Cumulative Layout Shift (CLS)** | 0.15 | <0.1 | -33% |
| **Total Bundle Size** | ~450KB | ~280KB | -38% |
| **Database Query Time** | ~150ms | ~50ms | -67% |
| **Cache Hit Rate** | 0% | 80% | +‚àû |
| **Concurrent Users** | ~100 | ~500 | +400% |

---

## üõ†Ô∏è Plano de A√ß√£o Recomendado

### Semana 1: Quick Wins
**Segunda**: Loading States + Bullet Setup
**Ter√ßa**: Identificar e corrigir N+1 queries
**Quarta**: Implementar Russian Doll Caching
**Quinta**: Testar e ajustar cache strategy
**Sexta**: Deploy e monitoramento

**Resultado Esperado**: +50% em performance percebida

---

### Semana 2: High Impact
**Segunda**: Lazy Loading de Imagens
**Ter√ßa**: Skeleton Screens (componentes)
**Quarta**: Skeleton Screens (implementa√ß√£o)
**Quinta**: Code Splitting e Preloading
**Sexta**: Testes de performance e ajustes

**Resultado Esperado**: +40% em m√©tricas Core Web Vitals

---

### Semana 3-4: Strategic
**Semana 3**: Service Worker + Background Jobs
**Semana 4**: HTTP/2 + Database Pooling

**Resultado Esperado**: Sistema pronto para escala 5x

---

## üìà ROI Estimado

### Investimento Total
- **Tempo**: 82-128 horas (~2-3 meses part-time)
- **Custo**: $0 (apenas tempo de desenvolvimento)
- **Ferramentas**: APM ($99/m√™s), CDN ($20/m√™s)

### Retorno Esperado
- **Performance**: +150% melhoria geral
- **UX**: +40% em satisfa√ß√£o do usu√°rio
- **Escalabilidade**: +400% capacidade de usu√°rios
- **Custos Infraestrutura**: -30% (melhor uso de recursos)
- **Tempo de Desenvolvimento**: -20% (debug mais f√°cil)

**ROI Total**: üöÄ **+500% em 6 meses**

---

## ‚úÖ Checklist de Implementa√ß√£o

### Performance
- [ ] Loading states implementados
- [ ] N+1 queries eliminados
- [ ] Russian Doll Caching ativo
- [ ] Lazy loading de imagens
- [ ] Code splitting configurado
- [ ] HTTP/2 ativo
- [ ] Brotli compression ativa

### UX
- [ ] Skeleton screens criados
- [ ] Loading indicators consistentes
- [ ] Error boundaries implementados
- [ ] Offline fallbacks funcionando
- [ ] Transitions suaves

### Infrastructure
- [ ] Database pooling otimizado
- [ ] Background jobs expandidos
- [ ] Service worker avan√ßado
- [ ] CDN configurado (opcional)

### Monitoring
- [ ] APM instalado e configurado
- [ ] Web Vitals tracking ativo
- [ ] Error tracking aprimorado
- [ ] Performance dashboards criados

---

## üéì Recursos e Refer√™ncias

### Performance
- [Rails Performance Guide](https://guides.rubyonrails.org/performance_testing.html)
- [Hotwire Performance](https://hotwired.dev)
- [Web.dev Performance](https://web.dev/performance/)

### Tools
- [Bullet Gem](https://github.com/flyerhzm/bullet)
- [Scout APM](https://scoutapm.com)
- [Web Vitals](https://github.com/GoogleChrome/web-vitals)

### Best Practices
- [Rails Caching Guide](https://guides.rubyonrails.org/caching_with_rails.html)
- [Turbo Handbook](https://turbo.hotwired.dev/handbook/introduction)
- [Stimulus Best Practices](https://stimulus.hotwired.dev/handbook/introduction)

---

**√öltima atualiza√ß√£o**: 28 de Outubro de 2025
**Status**: üìã Ready for Implementation
**Pr√≥xima Revis√£o**: Ap√≥s implementa√ß√£o das Quick Wins
